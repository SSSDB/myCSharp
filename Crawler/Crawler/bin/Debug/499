<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="前言 程序开发过程中,难免会有的业务逻辑,或者算法之类产生让人能够感知的耗时操作,例如循环中对复杂逻辑处理;获取数据库百万乃至千万级数据;http请求的时候等...... 用户在使用UI操作并不知道程" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>C# 根据BackgroundWorker异步模型和ProgressBar控件,自定义进度条控件 - 还在学 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.ico?v=20200522" type="image/x-icon" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=KCO3_f2W_TC__-jZ7phSnmoFkQuWMJH2yAgA16eE3eY" />
    <link id="MainCss" rel="stylesheet" href="/skins/codinglife/bundle-codinglife.min.css?v=UeHyLv1TT2WTz4TwfUOiMoKNmtFvLUjUnIhFE2UmZ7I" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/codinglife/bundle-codinglife-mobile.min.css?v=XjHfryC9ctsatIZz1dHn7TsRIqmwz9c3aj_6SCfHSDM" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/Ligy97/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/Ligy97/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/Ligy97/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=6bwfCY2e02dLOXNW99G2BHZkYFmw9QyYTWeJ-W-sudo"></script>
    <script>
        var currentBlogId = 603798;
        var currentBlogApp = 'Ligy97';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'CodingLife';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/Ligy97/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/Ligy97/">还在学</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/Ligy97/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E8%BF%98%E5%9C%A8%E5%AD%A6">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/Ligy97/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
2&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
0</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/Ligy97/p/12993155.html">C# 根据BackgroundWorker异步模型和ProgressBar控件,自定义进度条控件</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
    <h3 id="前言">前言</h3>
<blockquote>
<p>程序开发过程中,难免会有的业务逻辑,或者算法之类产生让人能够感知的耗时操作,例如循环中对复杂逻辑处理;获取数据库百万乃至千万级数据;http请求的时候等......<br>
用户在使用UI操作并不知道程序的内部处理,从而误操作导致程序无响应,关闭程序等待影响体验的情况,因此,在等待过程中提供友好的等待提示是有必要的,接下来<br>
我们一起封装一个自定义进度条控件!</p>
</blockquote>
<h3 id="主要使用技术c相关">主要使用技术(C#相关)</h3>
<ul>
<li><code>BackgroundWoker</code>异步模型</li>
<li><code>ProgressBar</code>控件</li>
<li>泛型</li>
<li>定时器 <code>System.Timers.Timer</code></li>
</ul>
<h1 id="自定义控件开发">自定义控件开发</h1>
<h2 id="项目解决方案">项目解决方案</h2>
<p><img src="https://img2020.cnblogs.com/blog/2038148/202005/2038148-20200530160015430-1748107377.png" alt=""></p>
<ul>
<li>BackgroundworkerEx : 自定义进度条控件工程</li>
<li>Test : 调用BackgroundworkerEx的工程(只是展示如何调用)</li>
</ul>
<h2 id="处理控件样式">处理控件样式</h2>
<p><img src="https://img2020.cnblogs.com/blog/2038148/202005/2038148-20200530160040557-817681224.png" alt=""></p>
<ul>
<li>
<p>新建一个ProgressbarEx名称的 <u><strong>用户控件</strong></u></p>
</li>
<li>
<p>添加Labal控件(lblTips),用于展示进度条显示的信息状态</p>
</li>
<li>
<p>添加一个PictureBox控件(PicStop),充当关闭按钮,用于获取用户点击事件,触发关闭/终止进度条</p>
</li>
<li>
<p>添加进度条ProgressBar控件(MainProgressBar)</p>
</li>
<li>
<p>处理代码如下:</p>
</li>
</ul>
<ol>
<li>进度条样式为&quot;不断循环&quot;,并且速度为50</li>
<li>该自定义用户控件不展示在任务栏中</li>
<li>图片控件被点击事件------&gt;设置当前属性<code>IsStop=true</code>,指示过程终止;</li>
<li><code>TipMessage</code>属性,用于设置进度条的信息</li>
<li><code>SetProgressValue(int value)</code> 设置进度条的<code>Value</code>属性,使得在<code>ProgressBarStyle.Marquee</code>样式中动画平滑</li>
<li><code>MouseDown</code>/<code>MouseUp</code>/<code>MouseMove</code>这三个事件是用于拖动无边框的用户控件(<u>代码就不贴了</u>)</li>
</ol>
<pre><code class="language-c#">public ProgressbarEx()
{
    InitializeComponent();

    MainProgressBar.Style = ProgressBarStyle.Marquee;
    MainProgressBar.MarqueeAnimationSpeed = 50;

    this.ShowInTaskbar = false;

    PicStop.Click += (s, eve) =&gt;
    {
    IsStop = true;
    };

    this.MouseDown += CusProgressForm_MouseDown;
    this.MouseUp += CusProgressForm_MouseUp;
    this.MouseMove += CusProgressForm_MouseMove;
}

/// &lt;summary&gt;
/// Need Stop ?
/// &lt;/summary&gt;
public bool IsStop { get; private set; } = false;

/// &lt;summary&gt;
/// TipMessage
/// &lt;/summary&gt;
public string TipMessage { get; set; }

/// &lt;summary&gt;
/// TipMessage
/// &lt;/summary&gt;
public string TipMessage
{
    get
    {
    return lblTips.Text;
    }
    set
    {

    lblTips.Text = value;
    }
}

/// &lt;summary&gt;
/// Set ProgressBar value ,which makes ProgressBar smooth
/// &lt;/summary&gt;
/// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
public void SetProgressValue(int value)
{
    if (MainProgressBar.Value == 100) MainProgressBar.Value = 0;

    MainProgressBar.Value += value;

}

</code></pre>
<p>到现在,这个自定义进度条控件的样式基本完成了.</p>
<h2 id="功能逻辑处理">功能逻辑处理</h2>
<h4 id="运行前所需">运行前所需</h4>
<ul>
<li>定义<code>BackgroundWorkerEx&lt;T&gt;</code>泛型类,并且继承于 <code>IDisposable</code>
<ol>
<li>释放资源;</li>
</ol>
</li>
</ul>
<pre><code class="language-C#"> 		/// &lt;summary&gt;
        /// Dispose
        /// &lt;/summary&gt;
        public void Dispose()
        {
            try
            {
                DoWork = null;
                RunWorkCompleted = null;
                WorkStoped = null;

                _mWorkerThread = null;
                _mWorker.Dispose();
                _mWorker = null;
                _mTimer = null;
            }
            catch (Exception){}
        }
</code></pre>
<ol start="2">
<li><code>T</code>用与异步处理的时候,传递<code>T</code>类型</li>
</ol>
<ul>
<li>因为我们是通过.Net 的 <code>BackgroundWorker</code>异步模型来做的,所以我们理所当然定义相关的事件:
<ol>
<li>异步开始</li>
<li>异步完成</li>
<li>加上我们自定义扩展的异步停止</li>
<li>......报告进度事件在此进度条样式中并不需要</li>
</ol>
</li>
</ul>
<p>我们先定义这四个事件所用到的参数,因为在<code>BackgroundWorkerEx&lt;T&gt;</code>泛型类中,我们还是使用<code>BackgroundWorker</code>来处理异步过程,因此我们定义的参数泛型类需要继承原来的参数类型,并且在传输传递中,将原生<code>BackgroundWorker</code>的<code>Argument</code>,<code>Result</code>属性转成全局的泛型T,这样我们在外部调用的时候,拿到的返回结果就是我们传入到<code>BackgroundWorkerEx&lt;T&gt;</code>泛型类中的<code>T</code>类型,而不需要使用<code>as</code>进行转换;  注:<u>因为原生没有停止相关事件,所以自定义异步停止的事件参数使用的是<code>DoWorkEventArgs&lt;T&gt;</code></u></p>
<pre><code class="language-C#">    public class DoWorkEventArgs&lt;T&gt; : DoWorkEventArgs
    {
        public new T Argument { get; set; }
        public new T Result { get; set; }
        public DoWorkEventArgs(object argument) : base(argument)
        {
            Argument = (T)argument;
        }
    }


    public class RunWorkerCompletedEventArgs&lt;T&gt; : RunWorkerCompletedEventArgs
    {
        public new T Result { get; set; }
        public RunWorkerCompletedEventArgs(object result, Exception error, bool cancelled) : base(result, error, cancelled)
        {
            Result = (T)result;
        }
    }
</code></pre>
<p>接着我们需要去定义事件,参数使用以上定义的泛型类</p>
<pre><code class="language-C#">	public delegate void DoWorkEventHandler(DoWorkEventArgs&lt;T&gt; Argument);
        /// &lt;summary&gt;
        /// StartAsync
        /// &lt;/summary&gt;
        public event DoWorkEventHandler DoWork;

        public delegate void StopEventHandler(DoWorkEventArgs&lt;T&gt; Argument);
        /// &lt;summary&gt;
        /// StopAsync
        /// &lt;/summary&gt;
        public event StopEventHandler WorkStoped;

        public delegate void RunWorkCompletedEventHandler(RunWorkerCompletedEventArgs&lt;T&gt; Argument);
        /// &lt;summary&gt;
        /// FinishAsync
        /// &lt;/summary&gt;
        public event RunWorkCompletedEventHandler RunWorkCompleted;
</code></pre>
<ul>
<li>定义全局的字段
<ol>
<li><code>private BackgroundWorker _mWorker = null;</code>异步操作必要;</li>
<li><code>private T _mWorkArg = default(T);</code>操作传递进来的参数类并且返回到外部</li>
<li><code>private Timer _mTimer;</code> 定时器检测自定义进度条控件属性<code>IsStop</code>是否为<code>true</code>,并且动态修改进度条消息</li>
<li><code>private Thread _mWorkerThread = null;</code>异步操作在该线程中,终止时调用<code>About()</code>抛出<code>ThreadAbortException</code>异常,用于标记当前是停止而不是完成状态</li>
<li><code>private int _miWorkerStartDateSecond = 0;</code> 异步消耗时间(非必要)</li>
<li><code>private int _miShowProgressCount = 0;</code> 动态显示&quot;.&quot;的个数(非必要)</li>
<li><code>private ProgressbarEx _mfrmProgressForm = null;</code> 自定义进度条控件实例</li>
</ol>
</li>
</ul>
<pre><code class="language-C#">        /// &lt;summary&gt;
        /// .Net  BackgroundWorker
        /// &lt;/summary&gt;
        private BackgroundWorker _mWorker = null;

        /// &lt;summary&gt;
        /// Whole Para
        /// &lt;/summary&gt;
        private T _mWorkArg = default(T);

        /// &lt;summary&gt;
        /// Timer
        /// &lt;/summary&gt;
        private Timer _mTimer = null;

        /// &lt;summary&gt;
        /// WorkingThread
        /// &lt;/summary&gt;
        private Thread _mWorkerThread = null;

        /// &lt;summary&gt;
        /// Async time sec
        /// &lt;/summary&gt;
        private int _miWorkerStartDateSecond = 0;

        /// &lt;summary&gt;
        /// Async time dot
        /// &lt;/summary&gt;
        private int _miShowProgressCount = 0;

        /// &lt;summary&gt;
        /// ProgressbarEx
        /// &lt;/summary
        private ProgressbarEx _mfrmProgressForm = null;

</code></pre>
<ul>
<li>定义全局属性</li>
</ul>
<ol>
<li><code>IsBusy</code> 返回<code>_mWorker</code>的工作忙碌是否</li>
<li><code>ProgressTip</code> 自定义进度条控件显示内容</li>
</ol>
<pre><code class="language-C#">	/// &lt;summary&gt;
        /// Express Busy
        /// &lt;/summary&gt;
        public bool IsBusy
        {
            get
            {
                if (_mWorker != null)
                {
                    return _mWorker.IsBusy;
                }
                return false;
            }
        }

        /// &lt;summary&gt;
        /// 进度条提示 默认： 正在加载数据，请稍后[{0}]{1}
        /// &lt;/summary&gt;
        public string ProgressTip { get; set; } = &quot;Elapsed Time[{0}]{1}&quot;;
</code></pre>
<p>**到现在,我们已经将必要的字段,属性,样式都处理完成!!! ** <strong>接下来我们就要实现方法</strong></p>
<h4 id="方法实现">方法实现</h4>
<ul>
<li>
<p><strong>异步工作事件</strong>,用法与<code>BackgroundWorker</code>一致,</p>
<ol>
<li>
<p>如果调用处没有注册<code>DoWork</code>事件,则直接返回</p>
</li>
<li>
<p>将接受到的参数创建成泛型参数类</p>
</li>
<li>
<p>开线程,将异步操作放在该线程中操作,注意设置线程的<code>IsBackground=true</code>,防止主进程意外退出,线程还在处理</p>
</li>
<li>
<p>循环直到线程结束</p>
</li>
<li>
<p><code>e.Result = Argument.Result;</code>将结果赋予<code>Result</code>,在停止或者完成事件中可以获取到结果</p>
</li>
</ol>
</li>
</ul>
<pre><code class="language-C#">		/// &lt;summary&gt;
        /// Working
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
        private void Worker_DoWork(object sender, DoWorkEventArgs e)
        {
            if (DoWork == null)
            {
                e.Cancel = true;
                return;
            }

            DoWorkEventArgs&lt;T&gt; Argument = new DoWorkEventArgs&lt;T&gt;(e.Argument);

            try
            {
                if (_mWorkerThread != null &amp;&amp; _mWorkerThread.IsAlive)
                {
                    _mWorkerThread.Abort();
                }
            }
            catch (Exception)
            {
                Thread.Sleep(50);
            }

            _mWorkerThread = new Thread(a =&gt;
            {
                try
                {
                    DoWork?.Invoke(a as DoWorkEventArgs&lt;T&gt;);
                }
                catch (Exception)
                {

                }
            });

            _mWorkerThread.IsBackground = true;
            _mWorkerThread.Start(Argument);

            //Maybe cpu do not start thread
            Thread.Sleep(20);

            //Wait.....
            while (_mWorkerThread.IsAlive)
            {
                Thread.Sleep(50);
            }
            e.Result = Argument.Result;
        }
</code></pre>
<ul>
<li>
<p><strong>异步完成/停止</strong></p>
<p><u>当线程停止抛出异常(catch但是不处理)/线程完成时会进入异步完成事件</u></p>
<ol>
<li>完成后,将自定义进度条控件实例关闭,释放</li>
</ol>
</li>
</ul>
<ol start="2">
<li>将全局的<code>BackgroundWorker</code>实例<code>_mWorker</code>相关事件取消注册,并且检查线程情况</li>
<li>感觉线程情况,如果线程状态为<code>ThreadState.Aborted</code>意味着线程被停止了,调用停止事件,否则调用完成事件</li>
</ol>
<pre><code class="language-C#">	  /// &lt;summary&gt;
      /// Completed
      /// &lt;/summary&gt;
      /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
      /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt;
      private void Worker_RunWorkCompleted(object sender, RunWorkerCompletedEventArgs e)
      {
          try
          {
              if (_mfrmProgressForm != null)
              {
                _mfrmProgressForm.Close();
                  _mfrmProgressForm.Dispose();
                _mfrmProgressForm = null;
              }

                if (_mWorker != null)
                {
                    _mWorker.DoWork -= Worker_DoWork;
                    _mWorker.RunWorkerCompleted -= Worker_RunWorkCompleted;

                    try
                    {
                        if (_mWorkerThread != null &amp;&amp; _mWorkerThread.IsAlive) _mWorkerThread.Abort();
                    }
                    catch (Exception) { }
                }

              //In timer, When stop progress will make thread throw AbortException
              if (_mWorkerThread != null &amp;&amp; _mWorkerThread.ThreadState == ThreadState.Aborted)
            {
                  WorkStoped?.Invoke(new DoWorkEventArgs&lt;T&gt;(_mWorkArg));
              }
              else
              {
                  RunWorkCompleted?.Invoke(new RunWorkerCompletedEventArgs&lt;T&gt;(e.Result, e.Error, e.Cancelled));
              }
          }
          catch (Exception ex)
          {
              throw ex;
          }
      }
</code></pre>
<ul>
<li>
<p><strong>线程开始</strong></p>
<ol>
<li>检查消息提醒内容 , {0}{1}同于显示异步耗时和&quot;..&quot;的个数</li>
<li>在定时器执行方法中,检查<code>_mfrmProgressForm.IsStop</code>是否为true,这个属性标志是否被停止;true则抛出异常</li>
<li><code>_mfrmProgressForm</code>不为<code>Null</code>则不断修改当前的内容提醒,友好化,实际可以按需处理</li>
</ol>
<pre><code class="language-C#">		  /// &lt;summary&gt;
        /// Timer Start 
        /// &lt;/summary&gt;
        private void StartTimer()
        {
            //Check user ProgressTip
            if (!ProgressTip.Contains(&quot;{0}&quot;))
            {
                ProgressTip += &quot;...Elapsed Time{0}{1}&quot;;
            }

            if (_mTimer != null) return;

            //On one sec 
            _mTimer = new Timer(1000);
            _mTimer.Elapsed += (s, e) =&gt;
            {
                //progress and it's stop flag (picture stop)||  this stop flag
                if (_mfrmProgressForm != null &amp;&amp; _mfrmProgressForm.IsStop)
                {
                    if (_mWorker != null)
                    {
                        try
                        {
                            if (_mWorkerThread != null &amp;&amp; _mWorkerThread.IsAlive)
                            {
                                if (_mTimer != null &amp;&amp; _mTimer.Enabled)
                                {
                                    _mTimer.Stop();
                                    _mTimer = null;
                                }
                                _mWorkerThread.Abort();
                            }
                        }
                        catch (Exception) { }
                    }
                }

                if (_mfrmProgressForm != null)
                {
                    //Callback 
                    _mfrmProgressForm.Invoke(new Action&lt;DateTime&gt;(elapsedtime =&gt;
                    {
                        DateTime sTime = elapsedtime;

                        //worked time
                        _miWorkerStartDateSecond++;
                        if (_mfrmProgressForm != null)
                        {
                            _mfrmProgressForm.SetProgressValue(_miWorkerStartDateSecond);
                        }

                        //.....count
                        _miShowProgressCount++;

                        if (_miShowProgressCount &gt; 6)
                        {
                            _miShowProgressCount = 1;
                        }

                        string[] strs = new string[_miShowProgressCount];

                        string ProgressStr = string.Join(&quot;.&quot;, strs);

                        string ProgressText = string.Format(ProgressTip, _miWorkerStartDateSecond, ProgressStr);

                        if (_mfrmProgressForm != null)
                        {
                            _mfrmProgressForm.TipMessage = ProgressText;
                        }
                    }), e.SignalTime);
                }
            };

            if (!_mTimer.Enabled)
            {
                _mTimer.Start();
            }
        }
</code></pre>
</li>
<li>
<p>**最后一步:异步开始 **  与<code>BackgroundWorker</code>用法一致,只是在最后开始了定时器和进度条控件而已</p>
<pre><code class="language-c#">/// &lt;summary&gt;
        /// Start AsyncWorl
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;Para&quot;&gt;&lt;/param&gt;
        public void AsyncStart(T Para)
        {
            //if workeven is  null ,express user do not regist event
            if (DoWork == null)
            {
                return;
            }

            _miWorkerStartDateSecond = 0;
            _miShowProgressCount = 0;

            //init
            if (_mWorker != null &amp;&amp; _mWorker.IsBusy)
            {
                _mWorker.CancelAsync();
                _mWorker = null;
            }

            _mWorker = new BackgroundWorker();

            //create progressbar
            _mfrmProgressForm = new ProgressbarEx();

            //add event
            _mWorker.DoWork += Worker_DoWork;
            _mWorker.RunWorkerCompleted += Worker_RunWorkCompleted;

            _mWorker.WorkerReportsProgress = true;
            _mWorker.WorkerSupportsCancellation = true;

            //Set Whole Para
            _mWorkArg = Para;

            _mWorker.RunWorkerAsync(Para);
            //Start timer
            StartTimer();

            _mfrmProgressForm.StartPosition = FormStartPosition.CenterParent;
            _mfrmProgressForm.ShowDialog();
        }
</code></pre>
</li>
</ul>
<blockquote>
<p>到这里,整个的进度条控件已经完成了!</p>
</blockquote>
<h2 id="调用">调用</h2>
<ul>
<li>定义一个参数类</li>
</ul>
<pre><code class="language-c#">	/// &lt;summary&gt;
    /// Para Class
    /// &lt;/summary&gt;
    public class ParaArg
    {
        public DataTable Data { get; set; }
        public string Msg { get; set; }
        public Exception Ex { get; set; }
    }
</code></pre>
<ul>
<li>定义全局的帮助类<code>BackgroundWorkerEx&lt;ParaArg&gt; workHelper = null;</code></li>
<li>调用</li>
</ul>
<pre><code class="language-C#">				if (workHelper != null || (workHelper != null &amp;&amp; workHelper.IsBusy))
                {
                    workHelper.Dispose();
                    workHelper = null;
                }
                if (workHelper == null)
                {
                    workHelper = new BackgroundWorkerEx&lt;ParaArg&gt;();
                }

                workHelper.DoWork += (eve) =&gt;
                {
                    ParaArg args = eve.Argument;

                    try
                    { 
                        //ToDo  like Thread.Sleep(20000);
                        Thread.Sleep(10000);
                        args.Msg = &quot;...this is bussiness code result&quot;;
                        throw new Exception(&quot;&quot;);
                    }
                    catch (Exception ex)
                    {
                        args.Ex = ex;
                    }
                    finally
                    {
                        eve.Result = args;
                    }

                };
                workHelper.RunWorkCompleted += (eve) =&gt;
                {
                    if (eve.Error != null)
                    {
                        //get .net backgroundworker exception;
                        //handle this exception;
                        //return ?
                    }

                    //get your para result
                    ParaArg x = eve.Result;
                 
                    if (x.Ex != null)
                    {
                        //get your bussiness exception;
                        //handle this exception;
                        //return ?
                    }

                    //finially get your need;
                    //MayBe to do some UI hanlde and bussiness logical
                    string sReusltMsg = x.Msg;
                };

                workHelper.WorkStoped += (eve) =&gt;
                { 
                    //if stoped ! it means no error;
                    //just get what you want; 
                    ParaArg x = eve.Result as ParaArg;

                    btnBegin.Enabled = true;
                };

                //参数
                ParaArg arg = new ParaArg()
                {
                    Msg = &quot;Msg&quot;
                };

                workHelper.AsyncStart(arg);

</code></pre>
<h2 id="最后">最后</h2>
<p>其实不管是封装的过程,还是调用,可以说完全就是<code>BackgroundWorker</code>的方式,所以很多<code>BackgroundWorker</code>相关的地方我都没有很详细的去说明;只要看看这个异步模型,就能够很好理解!大家有空也可以实现以下,有问题也可以详细,我比较喜欢交流技术~~~</p>
<p>还有一点就是这个解决方案已经放上Github上了,欢迎大家拉下来用</p>
<ul>
<li><strong><a href="https://github.com/Kurris/ProgressBarOnUserControl">GitHub地址</a> 欢迎star/fork</strong></li>
</ul>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-05-30 16:04</span>&nbsp;
<a href="https://www.cnblogs.com/Ligy97/">还在学</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12993155" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12993155);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 603798, cb_blogApp = 'Ligy97', cb_blogUserGuid = '79795a95-ed09-4a18-60aa-08d7f668918e';
    var cb_entryId = 12993155, cb_entryCreatedDate = '2020-05-30 16:04', cb_postType = 1; 
    loadViewCount(cb_entryId);
    loadSideColumnAd();
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;"></div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="sidebar_ad"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 还在学
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    
</body>
</html>
