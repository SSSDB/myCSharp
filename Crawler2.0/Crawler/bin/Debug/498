<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta property="og:description" content="前言 原型和原型链这方面的底层原理知识，一直以来都是面试市场上的一块的肥肉，也是每一位前端开发人员不得不掌握的内功心法。一直以来，我都想要搞懂弄明白的这部分知识，所以，就借这次重学前端将这方面的成果和" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>原型和原型链的深入探索 - 小玲慕斯 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.ico?v=20200522" type="image/x-icon" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=KCO3_f2W_TC__-jZ7phSnmoFkQuWMJH2yAgA16eE3eY" />
    <link id="MainCss" rel="stylesheet" href="/skins/simplememory/bundle-simplememory.min.css?v=OL4qeo1LNGlN1rKIhv5UctANvt0M6Nx6kLzr_ffx3Xk" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/SimpleMemory/bundle-SimpleMemory-mobile.min.css" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/yjiangling/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/yjiangling/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/yjiangling/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=6bwfCY2e02dLOXNW99G2BHZkYFmw9QyYTWeJ-W-sudo"></script>
    <script>
        var currentBlogId = 481192;
        var currentBlogApp = 'yjiangling';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'SimpleMemory';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/yjiangling/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/yjiangling/">小玲慕斯</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/yjiangling/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E5%B0%8F%E7%8E%B2%E6%85%95%E6%96%AF">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/yjiangling/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
31&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
6</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/yjiangling/p/12992741.html">原型和原型链的深入探索</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body ">
    <h1 class="md-end-block md-p"><span class="md-plain md-expand">前言</span></h1>
<p class="md-end-block md-p"><span class="md-plain">原型和原型链这方面的底层原理知识，一直以来都是面试市场上的一块的肥肉，也是每一位前端开发人员不得不掌握的内功心法。一直以来，我都想要搞懂弄明白的这部分知识，所以，就借这次重学前端将这方面的成果和自己的一些拙见整理一下，分享给大家。现在就从编程思想开始讲起吧。</span></p>
<p class="md-end-block md-p"><span class="md-plain">本文篇幅较长，如果只想了解原型和原型链的核心知识，建议可以直接从第三部分看起。</span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">一.编程思想</span></h1>
<p class="md-end-block md-p"><span class="md-plain">提起编程思想，这个概念在我的脑海中一直是一个非常模糊的概念，我所知道的是作为一名开发人员，每个人都应当具备这种能力，并且要不断地去探索到底怎么才能提高编程思想。那什么是编程思想呢？</span></p>
<p class="md-end-block md-p"><span class="md-plain">我觉得这个问题没有固定的答案，如果非要给一个定义，那大概就是用计算机来解决人们实际问题的思维方式，即编程思想。目前我所了解的编程思想有面向过程编程，结构化编程以及面向对象编程。</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">1.面向过程编程</span></h2>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>面向过程：POP（Process-oriented programming）</strong><span class="md-plain">就是分析出解决问题所需要的的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以了。这里举个栗子：将一只大象装进冰箱，就可以看做是面向过程的做法。</span></span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530144517034-994213861.png" alt="" width="674" height="154"></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>面向过程：就是按照我们分析好了的步骤，按照这个步骤解决问题。</strong></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">2.结构化编程</span></h2>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>结构化编程(Structured programming)：</strong><span class="md-plain">在程序设计的早期，程序采用流程图和自上而下的方式进行设计。这种设计方法的主要思路是将一个大问题分解为多个小问题进行解决，再针对每个小问题编写方法。总体上来说，是先构建一个主过程来启动程序流程，随后根据程序走向来调用相关的其他过程，这种程序设计思想就是结构化编程。</span></span></p>
<p class="md-end-block md-p"><span class="md-plain">举个经典的栗子：需要编写不同的工资计算方法，社保计算方法以及个人所得税计算方法。而如果从另一个角度看这个程序，则可以从判断判断该程序中的对象入手。该程序中的对象，最明显的就是&ldquo;员工&rdquo;！（小玲至今没弄懂工资咋算的，所以就随意画了一个工资计算的流程图，大家将就看看吧）</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530144537783-403107131.png" alt="" width="742" height="630"></p>
<h2 class="md-end-block md-heading"><span class="md-plain">3.面向对象编程</span></h2>
<p class="md-end-block md-p"><span class="md-plain">面向对象是把事物分解成一个个对象，然后由对象之间分工合作。</span></p>
<p class="md-end-block md-p"><span class="md-plain">举个栗子：将大象装进冰箱，面向对象的做法。（突然有点可怜这只大象了，老是被装进冰箱）</span></p>
<p class="md-end-block md-p"><span class="md-plain">先找出对象，并写出这些对象的功能</span></p>
<p class="md-end-block md-p"><span class="md-plain">（1）大象对象</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">进去</span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">（2）冰箱对象</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">打开</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">关闭</span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">（3）使用大象和冰箱的功能</span></p>
<p class="md-end-block md-p"><span class="md-pair-s "><strong>面向对象是以对象功能来划分问题，而不是步骤。</strong></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">4.三大编程思想的对比</span></h2>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>面向过程：</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</span></p>
<p class="md-end-block md-p"><span class="md-plain">缺点：没有面向对象易维护</span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>面向对象：</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">优点：易维护，易复用，易扩展，由于面向对象有封装，继承，多态性的特性，可以设计出低耦合的系统，使系统更加灵活，更加易于维护。</span></p>
<p class="md-end-block md-p"><span class="md-plain">缺点：性能比面向过程低。</span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>结构化编程：</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">优点：程序易于阅读、理解和维护，能将一个复杂的程序分解成若干个子结构，便于控制、降低程序的复杂性；提高了编程工作的效率，降低了软件开发成本</span></p>
<p class="md-end-block md-p"><span class="md-plain">缺点：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">用户要求难以在系统分析阶段准确定义，致使系统在交付使用时产生许多回问题。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">用系统开发每个阶段的成果来进行控制，不能适应事物变化的要求。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">系统的开发周期长。</span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">某大佬总结的：用面向过程的方式写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。（觉得有点意思，拿来用用）</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">5.深入面向对象</span></h2>
<p class="md-end-block md-p"><span class="md-plain">面向对象更贴近我们的实际生活，可以使用面向对象的思想来描述世界事物，但是事物分为具体的事物和抽象的事物。</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530144611783-1981576233.png" alt="" width="834" height="321"></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>面向对象编程：</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">程序中先用对象结构保存现实中一个事物的属性和功能，然后再按需使用事物的属性和功能，这种编程方法，就叫面向对象编程</span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>使用面向对象的原因：</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">便于大量数据的管理和维护</span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>面向对象的思维特点：</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">(1)抽取(抽象)对象共用的属性和行为组织(封装)成一个类(模板)</span></p>
<p class="md-end-block md-p"><span class="md-plain">(2)对类进行实例化，获取类的对象</span></p>
<p class="md-end-block md-p"><span class="md-plain">面向对象编程我们考虑的是有哪些对象；按照面向对象的思维特点，是不断的创建对象，使用对象，指挥对象做事情。</span></p>
<p class="md-end-block md-p"><span class="md-pair-s "><strong>面向对象的三大特点：</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">封装、继承和多态</span></p>
<p class="md-end-block md-p"><span class="md-plain">想要对编程思想有进一步了解的话，可以看看一位前辈写的<span class="md-meta-i-c  md-link"><a href="https://blog.csdn.net/shupan001/article/details/6824668"><span class="md-plain">一位十年软件工程师告诉你什么是编程思想</span></a><span class="md-plain">，相信你会有新的收获哦。</span></span></span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">二.对象</span></h1>
<h2 class="md-end-block md-heading"><span class="md-plain">1.什么是对象？</span></h2>
<p class="md-end-block md-p"><span class="md-plain">广义来讲，都说万物皆对象。对象是一个具体的事物，看的见摸得着的实物，例如：一本书，一支笔，一个人可以是"对象"，一个数据库、一张网页等也可以是&ldquo;对象&rdquo;。</span></p>
<p class="md-end-block md-p"><span class="md-plain">在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的实物都是对象，例如字符串，数值，数组，函数等。</span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>许多人都以为&ldquo;JavaScript 中万物都是对象&rdquo;，这是错误的。对象是 6 个（或者是 7 个，取 决于你的观点）基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同 的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。 对象就是键 / 值对的集合。可以通过 .propName 或者 ["propName"] 语法来获取属性值。</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain"> &mdash;&mdash;选自《你不知道的JavaScript(上卷)》 </span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">2.组成</span></h2>
<p class="md-end-block md-p"><span class="md-plain">对象是由属性和方法组成的：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">属性：事物的特征，在对象中用属性来表示（常用名词）</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">方法：事物的行为，在对象中用方法来表示（常用动词）</span></p>
</li>
</ul>
<h2 class="md-end-block md-heading"><span class="md-plain">3.何时使用对象？</span></h2>
<p class="md-end-block md-p"><span class="md-plain">今后只要使用面向对象的编程方式，都要先创建所需的所有对象，作为备用。</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">4.创建对象的几种方式</span></h2>
<p class="md-end-block md-p"><span class="md-plain"> 看到前辈们写的文章中一共提到了有以下五种方式：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">工厂模式(对象字面量)：用{}创建一个对象</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">构造函数模式：用new创建</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">原型对象模式：利用prototype创建</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">组合使用构造函数模式和原型模式 ：构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性(可以看成是重写原型对象)。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">动态原型模式</span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">可以看看<span class="md-meta-i-c  md-link"><a href="https://blog.csdn.net/dinglang_2009/article/details/7913866"><span class="md-plain">javascript中创建对象的几种方式</span></a><span class="md-plain"> 或者 <span class="md-meta-i-c  md-link"><a href="https://www.cnblogs.com/TRY0929/p/11870385.html"><span class="md-plain">JavaScript创建对象的几种方式</span></a><span class="md-plain">，讲解的非常详细。在这里我就只简单介绍其中三种</span></span></span></span></span></p>
<h3 class="md-end-block md-heading"><span class="md-plain">4.1 工厂模式(对象字面量)</span></h3>
<p class="md-end-block md-p"><span class="md-plain">今天上班第一天，先把小玲自己的信息记录一下~</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span> &nbsp; &nbsp; <span class="cm-keyword"><span class="cm-def"><span class="cm-operator"><span><span class="cm-property"><span class="cm-string"><span><span class="cm-property"><span class="cm-number"><span><span class="cm-property"><span class="cm-keyword"><span><span class="cm-variable"><span class="cm-property"><span class="cm-string"><span><span><span class="cm-variable"><span class="cm-property"><span class="cm-variable"><span><span class="cm-variable"><span class="cm-property"><span class="cm-comment">&nbsp;</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></pre>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span>   <span style="color: #0000ff;">var</span> person =<span style="color: #000000;"> {
</span><span style="color: #008080;">2</span>             uname:"xiaoling"<span style="color: #000000;">,
</span><span style="color: #008080;">3</span>             age:18<span style="color: #000000;">,
</span><span style="color: #008080;">4</span>             intr:<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;">5</span>                  console.log('我是小玲'<span style="color: #000000;">)}
</span><span style="color: #008080;">6</span> <span style="color: #000000;">   };
</span><span style="color: #008080;">7</span> <span style="color: #000000;">   console.log(person);
</span><span style="color: #008080;">8</span>    person.intr() <span style="color: #008000;">//</span><span style="color: #008000;">调用方法 </span></pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">现在我们来看一下，假如今天老板开会说，公司要再来三个新同事，让你记录一下她们的信息。</span></p>
<p class="md-end-block md-p"><span class="md-plain">然后你按照这种方式一会就完成了</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span> &nbsp; &nbsp;</span></pre>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span>         <span style="color: #0000ff;">var</span> person1 =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 2</span>             uname:"小张"<span style="color: #000000;">,
</span><span style="color: #008080;"> 3</span>             age:20<span style="color: #000000;">,
</span><span style="color: #008080;"> 4</span>             intr:<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;"> 5</span>                  console.log('我是小张1111'<span style="color: #000000;">)}
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        };
</span><span style="color: #008080;"> 7</span>         <span style="color: #0000ff;">var</span> person2 =<span style="color: #000000;"> {
</span><span style="color: #008080;"> 8</span>             uname:"小刘"<span style="color: #000000;">,
</span><span style="color: #008080;"> 9</span>             age:23<span style="color: #000000;">,
</span><span style="color: #008080;">10</span>             intr:<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;">11</span>                  console.log('我是小刘'<span style="color: #000000;">)}
</span><span style="color: #008080;">12</span> <span style="color: #000000;">        };
</span><span style="color: #008080;">13</span>         <span style="color: #0000ff;">var</span> person3 =<span style="color: #000000;"> {
</span><span style="color: #008080;">14</span>             uname:"小苏"<span style="color: #000000;">,
</span><span style="color: #008080;">15</span>             age:24<span style="color: #000000;">,
</span><span style="color: #008080;">16</span>             intr:<span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;">17</span>                  console.log('我是小苏'<span style="color: #000000;">)}
</span><span style="color: #008080;">18</span>         };</pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">如果按照这种字面量的方式去创建，不会感觉太傻瓜式了吗？假如老板说要增加一个特长 Specialty 的信息，你是否对要这些创建好的每一个对象都要进行添加修改呢？另外，请注意 person1 这个对象，因为小玲粗心了一下，不小心记录错误了。导致两个地方的属性 name 和 intr 方法中的打印的名字内容是不一致的。那么，这种问题能否在以后开发工作中避免呢？</span></p>
<p class="md-end-block md-p"><span class="md-plain">对于第二个问题，我们可以用this.属性名来代替方法中引用的对象属性即</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> console.log('我是'+<span style="color: #0000ff;">this</span><span style="color: #000000;">.uname)
</span><span style="color: #008080;">2</span> <span style="color: #008000;">//</span><span style="color: #008000;">或者</span>
<span style="color: #008080;">3</span> console.log(`我是${<span style="color: #0000ff;">this</span>.uname}`)</pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">关于this，每个函数都会自动携带（可以想象成天生就有），可以直接使用，指向正在调用函数的对象（谁调用，this就指向谁），所以person.intr(),intr中的this就指向person。</span></p>
<p class="md-end-block md-p"><span class="md-plain">对于第一个问题，我们可以用下面讲的构造函数来解决~</span></p>
<h3 class="md-end-block md-heading"><span class="md-plain">4.2 构造函数模式</span></h3>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>构造函数</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">构造函数式是一种特殊的函数，主要用来初始化对象，及为对象成员变量赋初始值，它总是与new一起使用。我们可以把对象中一些公用的属性和方法抽取出来，然后封装到这个函数里面。</span></p>
<p class="md-end-block md-p"><span class="md-pair-s "><strong>new在执行时做的四件事</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">①在内存中创建一个新的空对象</span></p>
<p class="md-end-block md-p"><span class="md-plain">②让this指向这个新的对象</span></p>
<p class="md-end-block md-p"><span class="md-plain">③执行构造函数里面的代码，给这个新对象添加属性和方法</span></p>
<p class="md-end-block md-p"><span class="md-plain">④返回这个新对象（所以构造函数里面不需要return）</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span> &nbsp; &nbsp;</span></pre>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span>     <span style="color: #008000;">//</span><span style="color: #008000;">2.构造函数模式</span>
<span style="color: #008080;"> 2</span>         <span style="color: #008000;">//</span><span style="color: #008000;">创建构造函数 Person    uname/age/intr 是实例成员</span>
<span style="color: #008080;"> 3</span>       <span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name,age){
</span><span style="color: #008080;"> 4</span>           <span style="color: #0000ff;">this</span>.uname =<span style="color: #000000;"> name;
</span><span style="color: #008080;"> 5</span>           <span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">​
</span><span style="color: #008080;"> 7</span>           <span style="color: #0000ff;">this</span>.intr = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;"> 8</span>               console.log(`我是${<span style="color: #0000ff;">this</span><span style="color: #000000;">.uname}`);
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">          }
</span><span style="color: #008080;">10</span> <span style="color: #000000;">      }
</span><span style="color: #008080;">11</span>         <span style="color: #008000;">//</span><span style="color: #008000;">创建实例</span>
<span style="color: #008080;">12</span>        <span style="color: #0000ff;">var</span> p1 = <span style="color: #0000ff;">new</span> Person('xiaoling',18<span style="color: #000000;">),
</span><span style="color: #008080;">13</span>            p2 = <span style="color: #0000ff;">new</span> Person('小张',20<span style="color: #000000;">),
</span><span style="color: #008080;">14</span>            p3 = <span style="color: #0000ff;">new</span> Person('小刘',23<span style="color: #000000;">);
</span><span style="color: #008080;">15</span> <span style="color: #000000;">​
</span><span style="color: #008080;">16</span>           console.log(p1); <span style="color: #008000;">//</span><span style="color: #008000;">Person {name: "xiaoling", age: 18, intr: &fnof;}</span>
<span style="color: #008080;">17</span>           console.log(p2); <span style="color: #008000;">//</span><span style="color: #008000;">Person {name: "小张", age: 20, intr: &fnof;}</span>
<span style="color: #008080;">18</span>           console.log(p3); <span style="color: #008000;">//</span><span style="color: #008000;">Person {name: "小刘", age: 23, intr: &fnof;}</span>
<span style="color: #008080;">19</span>         <span style="color: #008000;">//</span><span style="color: #008000;">调用方法</span>
<span style="color: #008080;">20</span>           p1.intr(); <span style="color: #008000;">//</span><span style="color: #008000;">我是xiaoling</span>
<span style="color: #008080;">21</span>           p2.intr(); <span style="color: #008000;">//</span><span style="color: #008000;">我是小张</span>
<span style="color: #008080;">22</span>           p3.intr(); <span style="color: #008000;">//</span><span style="color: #008000;">我是小刘</span>
<span style="color: #008080;">23</span>            console.log(Person.intr); <span style="color: #008000;">//</span><span style="color: #008000;">undefined</span>
<span style="color: #008080;">24</span> <span style="color: #000000;">​
</span><span style="color: #008080;">25</span>            Person.sex = '女';   <span style="color: #008000;">//</span><span style="color: #008000;">sex是静态成员</span>
<span style="color: #008080;">26</span>            console.log(Person.sex); <span style="color: #008000;">//</span><span style="color: #008000;">女</span>
<span style="color: #008080;">27</span>            console.log(p1.sex);  <span style="color: #008000;">//</span><span style="color: #008000;">undefined</span></pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">这里提几点：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s"><strong>构造函数中的属性和方法我们称为成员，成员可以添加</strong></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong>实例成员就是构造函数内部通过this添加的成员 ，如name,age，intr就是实例成员；实例成员只能通过实例化的对象来访问，如p1.uname。不能通过构造函数来访问实例成员，如Person.uname (这样是不允许的)</strong></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s"><strong>静态成员是在构造函数本身添加的成员，如sex就是静态成员。静态成员只能通过构造函数来访问，不能通过实例对象来访问（不可以用p1.sex访问）</strong></span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">这样，就能愉快地解决4.1的第一个问题啦！</span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>构造函数存在的问题</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">现在我们来看一下p1,p2,p3在内存中是怎样的？</span></p>
<p class="md-end-block md-p"><span class="md-plain"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530144651029-553985179.png" alt="" width="894" height="481"></span></p>
<p class="md-end-block md-p"><span class="md-plain">从上图中我们可以看到，创建多个不同的对象时，会同时在内存中开辟多个空间创建多个相同的函数，这些方法都是一样的。所以就存在浪费内存的问题。我们希望所有的对象使用同一个函数，这样会比较节省内存，那么这个问题改如何解决呢？</span></p>
<p class="md-end-block md-p"><span class="md-plain">利用原型对象的方式创建对象可以解决。</span></p>
<h3 class="md-end-block md-heading"><span class="md-plain">4.3 原型对象模式 -prototype</span></h3>
<p class="md-end-block md-p"><span class="md-plain">这节内容比较多，就单独在第三部分讲了~</span></p>
<p class="md-end-block md-p"><span class="md-plain">另：其他创建对象的方式请自行查阅资料了解（可以看看<span class="md-meta-i-c  md-link"><a href="https://blog.csdn.net/dinglang_2009/article/details/7913866"><span class="md-plain">javascript中创建对象的几种方式</span></a><span class="md-plain"> 或者 <span class="md-meta-i-c md-link"><a href="https://www.cnblogs.com/TRY0929/p/11870385.html"><span class="md-plain">JavaScript创建对象的几种方式</span></a><span class="md-plain">），这里我就不再讲了~ </span></span></span></span></span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">三.原型</span></h1>
<p class="md-end-block md-p"><span class="md-plain">先来简单介绍几个概念</span></p>
<h2 class="md-end-block md-heading"><span class="md-pair-s">1.构造函数</span></h2>
<p class="md-end-block md-p"><span class="md-plain">前面已经提过了，这里就再简单概括一下吧。</span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>构造函数式是一种特殊的函数，return会自动返回一个对象。使用时要搭配new使用，并且new会做4件非常重要的事。</strong></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">2.<span class="md-pair-s">原型对象</span></span></h2>
<p class="md-end-block md-p"><span class="md-plain">现在想想什么是原型呢？</span></p>
<p class="md-end-block md-p"><span class="md-plain">一个对象，我们也称prototype为原型对象，他具有共享方法的作用。</span></p>
<p class="md-end-block md-p"><span class="md-plain"> 其实在创建每个构造函数时，都会自动附赠一个空对象，名为原型对象(prototype)，属性名为prototype,这个属性指向函数的原型对象，同时这个属性是一个对象类型的值。通过 构造函数.prototype 属性，可获得这个构造函数对应的一个原型对象。</span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>构造函数通过原型对象分配的函数是所有对象共享的。</strong><span class="md-plain">JavaScript规定，每一个构造函数都有一个prototype属性，他指向另一个对象。请再次注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</span></span></p>
<p class="md-end-block md-p"><span class="md-plain">借用一张图来表示构造函数和实例原型之间的关系：</span></p>
<p class="md-end-block md-p"><span class="md-plain"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530144802873-1472773442.png" alt="" width="707" height="154"></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">3.<span class="md-pair-s">对象原型proto</span></span></h2>
<p class="md-end-block md-p"><span class="md-plain">对象都会有一个属性<span class="md-pair-s"><strong>proto</strong><span class="md-plain">指向构造函数的prototype原型对象，之所以我们的对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象对象有<span class="md-pair-s"><strong>proto</strong><span class="md-plain">原型的存在，那么对象的<span class="md-pair-s "><strong>proto</strong><span class="md-plain">是怎么存在的呢？</span></span></span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">我们来看一下这段话：</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]] 属性都会被赋予一个非空的值。 <br /><span><span>​<br /><span>注意：很快我们就可以看到，对象的 [[Prototype]] 链接可以为空，虽然很少见。<br /><span><span>​<br /><span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &mdash;&mdash;选自《你不知道的JavaScript(上卷)》 第五章</span></span></span></span></span></span></span></pre>
<p class="md-end-block md-p"><span class="md-plain">这段话的意思其实就是在告诉我们：每个对象都有&ldquo;<span class="md-pair-s"><strong>proro</strong><span class="md-plain">&rdquo;属性，这个属性会通过指针的方式指向其他对象，这个&ldquo;其他对象&rdquo;就是我们说的原型对象。当然除了顶级Object.prototype.<span class="md-pair-s"><strong>proto</strong><span class="md-plain">为null外，几乎所有的"<span class="md-pair-s"><strong>proto</strong><span class="md-plain">"都会指向一个非空对象。</span></span></span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">当我们用构造函数创建对象时，new的第二步自动为新对象添加"_ <span class="md-pair-s "><em>proto</em><span class="md-plain"> <span class="md-pair-s"><em>"属性，将"</em><span class="md-plain"> _ proto_ _"属性指向当前构造函数的原型对象。</span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-tab"> <span class="md-plain">比如: 如果var p1=new Person("xiaoling",18)</span></span></p>
<p class="md-end-block md-p"><span class="md-tab"> <span class="md-plain">则new会自动: p1._ <span class="md-pair-s "><em>proto</em><span class="md-plain"> _=Person.prototype。</span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">然后会有以下 结果: </span></p>
<p class="md-end-block md-p"><span class="md-tab"> <span class="md-plain">① 凡是这个构造函数创建出的新对象，都是原型对象的孩子(子对象)</span></span></p>
<p class="md-end-block md-p"><span class="md-tab"> <span class="md-plain">②放在原型对象中的属性值或方法，所有子对象无需重复创建，就可直接使用。</span></span></p>
<p class="md-end-block md-p"><span class="md-plain">看到这里，是否有点懵圈呢？别急，我们来画个图理一理</span></p>
<p class="md-end-block md-p"><span class="md-plain"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530144842034-279518684.png" alt="" width="644" height="351"></span></p>
<p class="md-end-block md-p"><span class="md-plain">如上图所示:构造函数的prorotype属性 和<span class="md-pair-s "><strong>proto</strong><span class="md-plain">对象原型指向的是同一个对象。</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">来证明一下吧在控制台打印一下这段代码：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> console.log(Person.prototype === p1.__proto__);<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">2</span> console.log(Person.prototype === p2.__proto__);<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">3</span> console.log(Person.prototype === p3.__proto__);<span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">我们发现结果都是true,那么说明<span class="md-pair-s "><strong>proto对象原型和原型对象prototype是等价的</strong><span class="md-plain">。或者说他们就是同一个对象，即：</span></span></span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>构造函数.prototype === 对应实例对象.proto</strong></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">4.原型对象模式</span></h2>
<p class="md-end-block md-p"><span class="md-plain">前面介绍了很多概念，现在来介绍一下原型对象prorotype集体是怎么实现的，其实很简单。</span></p>
<p class="md-end-block md-p"><span class="md-plain">构造函数.prototype.方法 = function(){ ... } </span></p>
<p class="md-end-block md-p"><span class="md-plain">具体看代码：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span>       <span style="color: #008000;">//</span><span style="color: #008000;">原型对象方式</span>
<span style="color: #008080;"> 2</span>          <span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name,age){
</span><span style="color: #008080;"> 3</span>           <span style="color: #0000ff;">this</span>.uname =<span style="color: #000000;"> name;
</span><span style="color: #008080;"> 4</span>           <span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">      }
</span><span style="color: #008080;"> 6</span>       Person.prototype.intr = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;"> 7</span>               console.log(`我是${<span style="color: #0000ff;">this</span><span style="color: #000000;">.uname}`);
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">          }
</span><span style="color: #008080;"> 9</span>         <span style="color: #008000;">//</span><span style="color: #008000;">创建实例</span>
<span style="color: #008080;">10</span>        <span style="color: #0000ff;">var</span> p1 = <span style="color: #0000ff;">new</span> Person('xiaoling',18<span style="color: #000000;">),
</span><span style="color: #008080;">11</span>            p2 = <span style="color: #0000ff;">new</span> Person('小张',20<span style="color: #000000;">),
</span><span style="color: #008080;">12</span>            p3 = <span style="color: #0000ff;">new</span> Person('小刘',23<span style="color: #000000;">);
</span><span style="color: #008080;">13</span>            console.log(p1); <span style="color: #008000;">//</span><span style="color: #008000;">Person {name: "xiaoling", age: 18}</span>
<span style="color: #008080;">14</span>           console.log(p2); <span style="color: #008000;">//</span><span style="color: #008000;">Person {name: "小张", age: 20}</span>
<span style="color: #008080;">15</span>           console.log(p3); <span style="color: #008000;">//</span><span style="color: #008000;">Person {name: "小刘", age: 23}</span></pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">我们来看控制台打印：</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530144906830-1654726741.png" alt=""></p>
<p class="md-end-block md-p"><span class="md-plain">我们会发现，打印结果并没有出现intr方法，那我们直接来调用一下试试吧</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008000;">//</span><span style="color: #008000;">调用intr方法</span>
<span style="color: #000000;">p1.intr()
p2.intr()
p3.intr()</span></pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">控制台结果：</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530144920464-1428515565.png" alt=""></p>
<p class="md-end-block md-p"><span class="md-plain">我们发现，居然可以直接调用，这是怎么回事呢？我们现在把p1,p2,p3在控制台打印的结果展开</span></p>
<p class="md-end-block md-p"><span class="md-plain"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145052295-466873424.gif" alt="" width="449" height="441"></span></p>
<p class="md-end-block md-p"><span class="md-image md-img-loaded" data-src="C:\Users\18846\Desktop\yujling\原型及原型链\img\8.gif"><img alt="" data-local-refresh="true"></span></p>
<p class="md-end-block md-p"><span class="md-plain">我们可以看到每个实例对象都有一个对象原型<span class="md-pair-s "><strong>proto</strong><span class="md-plain">,将它展开就能看到intr方法，难道实例对象调用成功的intr()是<span class="md-pair-s "><strong>proto</strong><span class="md-plain">上的吗？。我们知道实例对象的<span class="md-pair-s "><strong>proto</strong><span class="md-plain">就是构造函数的prototype,然而我们的intr方法就是定义在Person.prototype上的,所以，实例对象p1,p2,p3能够成功调用intr方法。</span></span></span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">我们来看一下，他们在内存中是怎么样的(简单画了一下)？</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530144944014-2135066475.png" alt="" width="594" height="364"></p>
<p class="md-end-block md-p"><span class="md-plain">我们可以看到，p1,p2,p3的__<span class="md-pair-s "><strong>proto__</strong><span class="md-plain">通过指针指向原型对象。我们知道原型对象是一个对象，所以intr在原型对象中存储的只是一个地址，这个地址会通过指针指向intr方法存储的位置。所以p1,p2,p3调用的intr方法，其实就是原型对象上的intr,他们共享同一个方法，这也正是前面提到的原型对象的作用：共享方法。</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">这样4.2提到的浪费内存的问题就完美的解决啦。虽然创建了三个实例对象，但是他们用的都是同一个方法（只占用了一份内存），就算咱们再创建3000,30000个对象，他们用的还是同一个方法，占用的内存依然只有一份，内存资源得到了大大的改善和节省，perfect!</span></p>
<p class="md-end-block md-p"><span class="md-plain">那我们再来思考一个问题：p1,p2,p3,自己没有uname,age,intr这些方法和属性，为什么可以使用呢?这就涉及到我们后面会讲的继承以及JavaScript的查找机制规则了.我们后面会说。</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">5.三者关系</span></h2>
<p class="md-end-block md-p"><span class="md-plain">在上文中，我们总是提到构造函数，原型（原型对象），实例，那么这三者之间到底有什么样的关系呢？</span></p>
<p class="md-end-block md-p"><span class="md-plain">目前我们已经知道的关系是：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s"><strong>构造函数.prototype 指向的是原型对象</strong></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong>实例对象的proto指向的也是原型对象</strong></span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">我们再来看一下这三个实例对象的打印结果，上图</span></p>
<p class="md-end-block md-p"><span class="md-plain"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145131934-391005928.gif" alt="" width="453" height="444"></span></p>
<p class="md-end-block md-p"><span class="md-image md-img-loaded" data-src="C:\Users\18846\Desktop\yujling\原型及原型链\img\8.gif"><img alt="" data-local-refresh="true"></span></p>
<p class="md-end-block md-p"><span class="md-plain">有看到什么额外的东西吗？请再仔细看一下！</span></p>
<p class="md-end-block md-p"><span class="md-plain">我们可以看到每个实例对象展开，他里面都有一个<span class="md-pair-s "><strong>proto</strong><span class="md-plain">,这个不是重点，重点是，每个<span class="md-pair-s "><strong>proto</strong><span class="md-plain">属性展开，他不仅仅有我们自己定义的方法intr，还有一个浅粉色的constructor属性，重点是我们可以看到这个这个constructor的值正好是我们的构造函数Person.</span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">咱们来验证一下，在控制台输出以下代码：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;">1</span> console.log(Person.prototype.constructor === Person); <span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">2</span> console.log(p1.__proto__.constructor === Person);<span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;">3</span> console.log(p2.__proto__.constructor === Person);<span style="color: #008000;">//</span><span style="color: #008000;">true console.log(p3.__proto__.constructor === Person);//true</span></pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">我们得到的结果是4个true,说明我们上文的猜想是正确的，也就是说构造函数也有一个属性constructor，这个constructor属性指向的是构造函数。既然构造函数能够出生的时候就有prototype属性--<span class="md-pair-s"><strong>创建每个构造函数时，都会自动附赠一个空对象，名为原型对象(prototype)</strong><span class="md-plain">，那我们是不是也可以把原型对象上凭空多出来的constructor当成是它天生就有的呢（哎！有些人注定了，出生就是不平凡的，自带光环）</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">好了，我们现在再来总结一下：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong>创建构造函数时，构造函数会附赠一个prototype属性，这个prototype属性以指针的方式指向一个对象，这个对象我们称为原型对象。</strong></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong>原型对象存在的同时，也会自动附赠一个constructor属性，这个属性以指针的方式指向他的构造函数。</strong></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong>用构造函数实例化对象时，会通过new这个动作做4件事。</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">①在内存中创建一个新的空对象</span></p>
<p class="md-end-block md-p"><span class="md-plain">②让this指向这个新的对象（自动设置新对象的_ <span class="md-pair-s "><em>proto</em><span class="md-plain"> _指向构造函数的原型对象&mdash;&mdash;继承）</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">③执行构造函数里面的代码，给这个新对象添加属性和方法</span></p>
<p class="md-end-block md-p"><span class="md-plain">④返回这个新对象（所以构造函数里面不需要return）</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-pair-s "><strong>实例对象创建时会自带一个内置属性</strong><span class="md-pair-s "><strong>proto</strong><span class="md-plain">,<span class="md-pair-s "><strong>这个</strong><span class="md-pair-s "><strong>proto</strong><span class="md-plain">属<span class="md-pair-s "><strong>性会通过指针的方式指向原型对象（我们可以称为父类）</strong></span></span></span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">再来画一个图看看他们之间的关系</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145210817-940818594.png" alt="" width="652" height="419"></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">再来看一张更详细的图</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145237653-1804300212.png" alt="" width="569" height="410"></p>
<p class="md-end-block md-p"><span class="md-plain">看完这张图，你是不是又懵圈了呢？没关系，请跟我一样拿起笔自己也在纸上画一画吧，如果你能画明白，说明你已经动了一大半了。如果还没有明白，我们一起再来捋一捋：</span></p>
<ol class="ol-list">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">构造函数Person生成的时候会自动存在一个prototype属性，即Person.prototype,我们称为原型对象。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">原型对象是一个对象，它存在的同时会自动生成一个constrctor属性，这个属性会自动指向他的构造函数，即Person。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">用new生成实例对象时，这个实力对象同时会携带一个<span class="md-pair-s "><strong>proto</strong><span class="md-plain">属性，这个属性会指向构造函数的原型对象，通过这个<span class="md-pair-s "><strong>proto</strong><span class="md-plain">,实例对象继承了原型对象上的所有方法，就是可以用原型对象上的方法。</span></span></span></span></span></p>
</li>
</ol>
<p class="md-end-block md-p"><span class="md-plain">其实不仅仅是实例对象，任何一个对象数据类型都存在这样的关系。</span></p>
<p class="md-end-block md-p"><span class="md-plain">再来看一张图，或许你会更加明白</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145320914-181277804.png" alt="" width="666" height="281"></p>
<p class="md-end-block md-p"><span class="md-plain"> (本图来自《JavaScript 高级程序设计》的图 6-1)</span></p>
<p class="md-end-block md-p"><span class="md-plain">好了，构造函数，原型对象，实例对象三者之间的关系就讲完了，如果还没有弄明白，建议多看几遍，看的同时自己动手在纸上画一画哦。</span></p>
<h1 class="md-end-block md-heading"><span class="md-pair-s"><strong>四.JavaScript的成员查找机制</strong></span></h1>
<p class="md-end-block md-p"><span class="md-plain">先直接讲一下规则：</span></p>
<p class="md-end-block md-p"><span class="md-plain">①当访问一个对象的属性(包括方法)时，首先查找这个对象有没有该属性。</span></p>
<p class="md-end-block md-p"><span class="md-plain">②如果没有就查找他的原型(也就是<span class="md-pair-s "><strong>proto</strong><span class="md-plain">指向的prototype原型对象)。</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">③如果还没有就查找原型对象的原型（Object的原型对象）。</span></p>
<p class="md-end-block md-p"><span class="md-plain">④以此类推一直到Object为止(null).</span></p>
<p class="md-end-block md-p"><span class="md-plain">⑤<span class="md-pair-s "><strong>proto</strong><span class="md-plain">对象原型的意义就在于为对象成员查找机制提供了一个方向，或者说一条路线。</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">这一部分看不明白没关系，先大概知道这个规则就行。</span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">五.原型链</span></h1>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">举例说明:person &rarr; Person &rarr; Object ，普通人继承人类，人类继承对象类</span></p>
<p class="md-end-block md-p"><span class="md-pair-s"><strong>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回null。这也是实例对象p1,p2,p3能够使用intr()方法的最重要的</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">上文说到&ldquo;如果在Object原型中依然没有找到，则返回null&rdquo;，这个一起来验证一下。我们先来看一下在浏览器执行的这些代码：</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145346475-905812472.png" alt=""></p>
<p class="md-end-block md-p"><span class="md-plain">我们知道任何一个原型对象都是一个对象，而每个对象都有<span class="md-pair-s "><strong>proto</strong><span class="md-plain">属性，所以Object的原型对象也是一个对象（可以看Object.prototype的打印结果就是一个对象），那么他的<span class="md-pair-s"><strong>proto</strong><span class="md-plain">就是上图我们打印的结果null.所以我们得到了验证结果</span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">即：<span class="md-pair-s "><strong>Object.prototype.proto = null</strong></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">所以在JavaScript中，Object是一等公民！</span></p>
<p class="md-end-block md-p"><span class="md-plain">现在我们把原型链画出来！</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145414437-1574584387.png" alt="" width="768" height="346"></p>
<p class="md-end-block md-p"><span class="md-plain">现在再看着这张图，重新读一遍第四和第五部分，你就会明白原型链了。</span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">六.构造器</span></h1>
<h2 class="md-end-block md-heading"><span class="md-plain">1.定义</span></h2>
<p class="md-end-block md-p"><span class="md-plain">本文没有构造器的定义(没有找到对它的准确定义)，真的要说它是什么只能说：构造函数。</span></p>
<p class="md-end-block md-p"><span class="md-plain">构造函数跟普通函数非常相似，我们已经说过构造函数时一种特殊的函数(第四部分4.2中),我可以通过<span class="md-pair-s"><code>new</code><span class="md-plain">关键字来使用它们。主要有两种类型的构造函数，<span class="md-pair-s"><code>native</code><span class="md-plain">构造函数（<span class="md-pair-s"><code>Array</code><span class="md-plain">,<span class="md-pair-s"><code>Object</code><span class="md-plain">等）它们可以在执行环境中自动生成，还有自定义的构造函数，你可以定义自己的方法和属性，比如我们自定义的Person构造函数。</span></span></span></span></span></span></span></span></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">2.<span class="md-pair-s"><code>native</code><span class="md-plain">构造函数</span></span></span></h2>
<p class="md-end-block md-p"><span class="md-plain">JavaScript中有内置(build-in)构造器/对象共计12个（<span class="md-meta-i-c md-link"><a href="http://kangax.github.com/es5-compat-table/"><span class="md-plain">ES5</span></a><span class="md-plain">中新加了JSON）：</span></span></span></p>
<p class="md-end-block md-p"><span class="md-pair-s "><strong>Object、Function、String、Number、Boolean、Array、RegExp、Data、Error、Math、JSON、Global</strong></span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">3.自定义构造函数</span></h2>
<p class="md-end-block md-p"><span class="md-plain">就是我们可以根据需要按照构造函数的方式定义自己的方法和属性就行。</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">4.一个重要结论</span></h2>
<p class="md-end-block md-p"><span class="md-pair-s "><strong>所有构造器/函数的proto都指向Function.prototype（Function.prototype是一个空函数）</strong></span></p>
<p class="md-end-block md-p"><span class="md-plain">怎么验证这句话呢？上代码：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span>         console.log(Boolean.__proto__ === Function.prototype); <span style="color: #008000;">//</span><span style="color: #008000;">true</span>
<span style="color: #008080;"> 2</span>         console.log(Number.__proto__ === Function.prototype); <span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #008080;"> 3</span>         console.log(String.__proto__ === Function.prototype);  <span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #008080;"> 4</span>         console.log( Object.__proto__ === Function.prototype); <span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #008080;"> 5</span>         console.log(Function.__proto__ === Function.prototype);  <span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #008080;"> 6</span>         console.log(Array.__proto__ === Function.prototype); <span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #008080;"> 7</span>         console.log(RegExp.__proto__ === Function.prototype); <span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #008080;"> 8</span>         console.log(Error.__proto__ === Function.prototype);  <span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #008080;"> 9</span>         console.log(Date.__proto__ === Function.prototype);<span style="color: #008000;">//</span><span style="color: #008000;"> true</span>
<span style="color: #008080;">10</span> <span style="color: #000000;">​
</span><span style="color: #008080;">11</span> <span style="color: #000000;">​
</span><span style="color: #008080;">12</span>         console.log(Function.prototype);</pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">结果：</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145542401-82506824.png" alt=""></p>
<p class="md-end-block md-p"><span class="md-plain">再来个自定义构造器：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span>          <span style="color: #008000;">//</span><span style="color: #008000;">自定义构造器</span>
<span style="color: #008080;"> 2</span>          <span style="color: #008000;">//</span><span style="color: #008000;">原型对象方式</span>
<span style="color: #008080;"> 3</span>          <span style="color: #0000ff;">function</span><span style="color: #000000;"> Person(name,age){
</span><span style="color: #008080;"> 4</span>           <span style="color: #0000ff;">this</span>.uname =<span style="color: #000000;"> name;
</span><span style="color: #008080;"> 5</span>           <span style="color: #0000ff;">this</span>.age =<span style="color: #000000;"> age;
</span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        }
</span><span style="color: #008080;"> 7</span>         Person.prototype.intr = <span style="color: #0000ff;">function</span><span style="color: #000000;">(){
</span><span style="color: #008080;"> 8</span>               console.log(`我是${<span style="color: #0000ff;">this</span><span style="color: #000000;">.uname}`);
</span><span style="color: #008080;"> 9</span> <span style="color: #000000;">          }
</span><span style="color: #008080;">10</span>         
<span style="color: #008080;">11</span>         console.log(Person.__proto__ === Function.prototype);  <span style="color: #008000;">//</span><span style="color: #008000;">true</span></pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">这说明什么呢？</span></p>
<p class="md-end-block md-p"><span class="md-plain">①JavaScript中的内置构造器/对象共计12个（<span class="md-meta-i-c  md-link"><a href="http://kangax.github.com/es5-compat-table/"><span class="md-plain">ES5</span></a><span class="md-plain">中新加了JSON）.上面列举了可访问的9个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的<span class="md-pair-s "><strong>proto</strong><span class="md-plain">是Object.prototype。如下</span></span></span></span></span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span>Math.__proto__ === Object.prototype // true<br /><span>JSON.__proto__ === Object.prototype // true</span></span></pre>
<p class="md-end-block md-p"><span class="md-plain">②所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind（ES5）。</span></p>
<p class="md-end-block md-p"><span class="md-plain">③Function.prototype也是唯一一个typeof XXX.prototype为 &ldquo;function&rdquo;的prototype。其它的构造器的prototype都是一个对象。</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145557502-51064031.png" alt=""></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span> &nbsp; &nbsp;</span></pre>
<div class="cnblogs_code">
<pre><span style="color: #008080;"> 1</span> console.log(<span style="color: #0000ff;">typeof</span> Function.prototype) <span style="color: #008000;">//</span><span style="color: #008000;"> function</span>
<span style="color: #008080;"> 2</span> console.log(<span style="color: #0000ff;">typeof</span> Object.prototype)   <span style="color: #008000;">//</span><span style="color: #008000;"> object</span>
<span style="color: #008080;"> 3</span> console.log(<span style="color: #0000ff;">typeof</span> Number.prototype)   <span style="color: #008000;">//</span><span style="color: #008000;"> object</span>
<span style="color: #008080;"> 4</span> console.log(<span style="color: #0000ff;">typeof</span> Boolean.prototype)  <span style="color: #008000;">//</span><span style="color: #008000;"> object</span>
<span style="color: #008080;"> 5</span> console.log(<span style="color: #0000ff;">typeof</span> String.prototype)   <span style="color: #008000;">//</span><span style="color: #008000;"> object</span>
<span style="color: #008080;"> 6</span> console.log(<span style="color: #0000ff;">typeof</span> Array.prototype)    <span style="color: #008000;">//</span><span style="color: #008000;"> object</span>
<span style="color: #008080;"> 7</span> console.log(<span style="color: #0000ff;">typeof</span> RegExp.prototype)   <span style="color: #008000;">//</span><span style="color: #008000;"> object</span>
<span style="color: #008080;"> 8</span> console.log(<span style="color: #0000ff;">typeof</span> Error.prototype)    <span style="color: #008000;">//</span><span style="color: #008000;"> object</span>
<span style="color: #008080;"> 9</span> console.log(<span style="color: #0000ff;">typeof</span> Date.prototype)     <span style="color: #008000;">//</span><span style="color: #008000;"> object</span>
<span style="color: #008080;">10</span> console.log(<span style="color: #0000ff;">typeof</span> Object.prototype)   <span style="color: #008000;">//</span><span style="color: #008000;"> object</span></pre>
</div>
<p>&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">④除了Function.prototype,所有构造函数的prototype都是一个对象</span></p>
<h2 class="md-end-block md-heading"><span class="md-plain">5.一等公民</span></h2>
<p class="md-end-block md-p"><span class="md-plain">前面原型链部分我们知道Objec是一等公民，那其实Function也是。</span></p>
<p class="md-end-block md-p"><span class="md-plain">我们已经知道了所有构造器（含内置及自定义）的<span class="md-pair-s"><strong>proto</strong><span class="md-plain">都是Function.prototype，那Function.prototype的<span class="md-pair-s "><strong>proto</strong><span class="md-plain">是谁呢？</span></span></span></span></span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-variable">console.<span class="cm-property">log(<span class="cm-variable">Function.<span class="cm-property">prototype.<span class="cm-property">__proto__ <span class="cm-operator">=== <span class="cm-variable">Object.<span class="cm-property">prototype) <span class="cm-comment">// true</span></span></span></span></span></span></span></span></span></span></pre>
<p class="md-end-block md-p"><span class="md-plain">这说明所有的构造器也都是一个普通JS对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</span></p>
<p class="md-end-block md-p"><span class="md-plain">最后再提一次：Object.prototype的<span class="md-pair-s "><strong>proto</strong><span class="md-plain">是谁？</span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain">前面我们已经验证过是null,到顶了</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span>Object.prototype.__proto__ === null // true</span></pre>
<p class="md-end-block md-p"><span class="md-plain">讲到这里，是不是又有点懵圈了呢？上图帮助你消化吧</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145622696-65574579.png" alt=""></p>
<p class="md-end-block md-p"><span class="md-plain">看图，一起理一理：</span></p>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">每个构造函数（不管是内置构造函数还是自定义的构造函数），他的<span class="md-pair-s "><strong>proto</strong><span class="md-plain">都指向Function.Prototype,包括Function他自己（Math和JSON不算在里面，因为他们的<span class="md-pair-s "><strong>proto</strong><span class="md-plain">指向的是Object.prototype）。</span></span></span></span></span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">每个构造函数都有一个内置属性即prototype,他们指向自己的原型对象，除了Function的原型对象是一个空函数外，所有构造函数的prototype都是一个对象。</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">每个原型对象都有一个内置属性constructor，属性，constructor属性指回原型对象的属性</span></p>
</li>
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain">Object是顶级对象，Object.prototype.<span class="md-pair-s "><strong>proto</strong><span class="md-plain">为null</span></span></span></p>
</li>
</ul>
<ul class="ul-list" data-mark="-">
<li class="md-list-item">
<p class="md-end-block md-p"><span class="md-plain"> 每个实例对象都有一个<span class="md-pair-s "><strong>proto</strong><span class="md-plain">属性，通过这个<span class="md-pair-s "><strong>proto</strong><span class="md-plain">属性，这个实例对象可以按照JavaScript的成员查找规则（本文第四部分），去使用原型链上的属性和方法，也就是我们说的继承父类的属性和方法的本质。这也是我们随便创建一个数组或者对象，能够使用toString()/valueOf() pop()/filter()/sort()等方法的原因。</span></span></span></span></span></p>
</li>
</ul>
<p class="md-end-block md-p"><span class="md-plain">现在再看这张图明白了嘛，回国头再去看一看第四部分：<span class="md-pair-s "><em>JavaScript的成员查找规则</em><span class="md-plain"> 是不是也顿悟了很多。</span></span></span></p>
<h1 class="md-end-block md-heading"><span class="md-plain">七.一张手绘原型链</span></h1>
<p class="md-end-block md-p"><span class="md-plain">请忽略我丑陋的字迹，能看懂这张图并且自己可以画出来，说明你今天的收获非常大哦~</span></p>
<p class="md-end-block md-p"><img src="https://img2020.cnblogs.com/blog/1556521/202005/1556521-20200530145631453-425742464.png" alt="" width="643" height="601"></p>
<p class="md-end-block md-p">&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">到这里我们就讲完原型和原型链相关的内容了，可能还有些地方没讲到，大家就自行下去再研究了。</span></p>
<p class="md-end-block md-p"><span class="md-plain">另外建议红宝书和你不知道系列多看几遍（「书读百遍其义自见」是很有道理的）。</span></p>
<p class="md-end-block md-p"><span class="md-plain">再推荐几位前辈写的不错的文章，值得多读几遍：</span></p>
<div class="footnotes md-def-link md-end-block">[<span class="md-def-name">​最详尽的 JS 原型与原型链终极详解，没有「可能是」] <span class="md-def-split md-def-f">&nbsp;<span class="md-def-content md-def-url md-auto-disp">https://www.jianshu.com/p/dee9f8b14771<span class="md-def-split md-auto-hide">&nbsp;</span></span></span></span></div>
<div class="footnotes md-def-link md-end-block">[<span class="md-def-name">​javascript中构造器（函数）的__proto__与prototype初探] <span class="md-def-split md-def-f">&nbsp;<span class="md-def-content md-def-url md-auto-disp">https://www.cnblogs.com/webjoker/p/5319377.html<span class="md-def-split md-auto-hide">&nbsp;</span></span></span></span></div>
<p class="md-end-block md-p">&nbsp;</p>
<h1 class="md-end-block md-heading"><span class="md-plain">后记</span></h1>
<p class="md-end-block md-p"><span class="md-plain">非常感谢大家能够认真看完这篇文章。其实在提笔写这篇文章之前，小玲的内心是非常紧张和忐忑的，因为害怕自己研究的不够深入和全面，但是一想到可以和大家分享我的收获，还是非常激动和兴奋的。可能有些地方讲的还不够清楚，大家可以自己多思考一下，你自己思考想出来的东西，比别人灌输给你的更能让你记忆深刻。如果，若有某个地方存在问题或者不明白的，欢迎大家积极提出宝贵的建议和见解！</span></p>
<p class="md-end-block md-p md-focus">&nbsp;</p>
<p class="md-end-block md-p"><span class="md-plain">参考文章：</span></p>
<p class="md-end-block md-p"><span class="md-link md-pair-s"><a href="https://www.cnblogs.com/TRY0929/p/11870385.html">https://www.cnblogs.com/TRY0929/p/11870385.html</a></span></p>
<p class="md-end-block md-p"><span class="md-link md-pair-s"><a href="https://www.jianshu.com/p/dee9f8b14771">https://www.jianshu.com/p/dee9f8b14771</a></span></p>
<p class="md-end-block md-p"><span class="md-link md-pair-s"><a href="https://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html">https://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html</a></span></p>
<p class="md-end-block md-p"><span class="md-link md-pair-s md-expand"><a href="https://www.cnblogs.com/webjoker/p/5319377.html">https://www.cnblogs.com/webjoker/p/5319377.html</a></span></p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-05-30 15:04</span>&nbsp;
<a href="https://www.cnblogs.com/yjiangling/">小玲慕斯</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12992741" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12992741);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 481192, cb_blogApp = 'yjiangling', cb_blogUserGuid = 'fdfe9849-0a68-4afa-d4d9-08d65a7b71fe';
    var cb_entryId = 12992741, cb_entryCreatedDate = '2020-05-30 15:04', cb_postType = 1; 
    loadViewCount(cb_entryId);
    loadSideColumnAd();
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;"></div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="sidebar_ad"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 小玲慕斯
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    
</body>
</html>
